<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[深挖洞，广积粮，不称霸]]></title>
  <subtitle><![CDATA[Uncover hot project's vulnerabilities]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://huntcve.github.io//"/>
  <updated>2017-05-04T08:03:59.000Z</updated>
  <id>http://huntcve.github.io//</id>
  
  <author>
    <name><![CDATA[Seven Shen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hunted CVEs]]></title>
    <link href="http://huntcve.github.io/2017/05/03/cveupdate/"/>
    <id>http://huntcve.github.io/2017/05/03/cveupdate/</id>
    <published>2017-05-03T03:08:39.000Z</published>
    <updated>2017-05-04T08:03:59.000Z</updated>
    <content type="html"><![CDATA[<p>个人挖掘的漏洞汇总，分析与PoC仅供学习使用：</p>
<p>-CVE-2015-1835:<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/trend-micro-discovers-apache-vulnerability-that-allows-one-click-modification-of-android-apps/" target="_blank" rel="external">Remote modify Cordova configurations</a>, <a href="https://github.com/huntcve/CVE/tree/master/CVE-2015-1835" target="_blank" rel="external">poc</a><br>-CVE-2015-3839:<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/two-new-android-bugs-mess-up-messaging-may-lead-to-multiple-send-charges/" target="_blank" rel="external">DoS Messaging app</a><br>-CVE-2015-3840:<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/two-new-android-bugs-mess-up-messaging-may-lead-to-multiple-send-charges/" target="_blank" rel="external">MMS/SMS status modify</a><br>-CVE-2015-3847:Arbitrary SMS removal<br>-CVE-2015-3851:<a href="https://android.googlesource.com/platform/packages/services/Telephony/+/aaf4c41e2e353be01fe9cd5f8ca97bf37565dc41" target="_blank" rel="external">Phone DoS/SIP profile removal</a><br>-CVE-2015-3852:<a href="https://android.googlesource.com/platform/packages/services/Telephony/+/dcec1e1471a1d32918b5a2beb239693708c548e7" target="_blank" rel="external">Device continue reboot</a><br>-CVE-2015-6600:<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/android-security-update-includes-fix-for-stagefright-vulnerabilities-discovered-by-trend-micro/" target="_blank" rel="external">Remote heap buffer overflow in media server</a><br>-CVE-2015-6610:Local heap buffer overflow in media server<br>-CVE-2016-0803:Remote heap buffer overflow in media server<br>-CVE-2016-2064:Qualcomm sound driver buffer overflow<br>-CVE-2016-2065:Qualcomm sound driver buffer overflow<br>-CVE-2016-2066:Qualcomm sound driver buffer overflow<br>-CVE-2016-2068:Qualcomm sound driver buffer overflow<br>-CVE-2016-3894:Qualcomm DMA driver info leak<br>-CVE-2016-3931:<a href="https://www.codeaurora.org/out-range-pointer-offset-qseecomsendmodfdresp-cve-2016-3931" target="_blank" rel="external">Qualcomm QSEE driver buffer overflow</a><br>-CVE-2016-6693:<a href="https://www.codeaurora.org/multiple-issues-qdsp6v2-driver-cve-2016-6693-cve-2016-6694-cve-2016-6695-cve-2016-6696" target="_blank" rel="external">Qualcomm sound driver buffer overflow </a><br>-CVE-2016-6694:<a href="https://www.codeaurora.org/multiple-issues-qdsp6v2-driver-cve-2016-6693-cve-2016-6694-cve-2016-6695-cve-2016-6696" target="_blank" rel="external">Qualcomm sound driver buffer overflow </a><br>-CVE-2016-6695:<a href="https://www.codeaurora.org/multiple-issues-qdsp6v2-driver-cve-2016-6693-cve-2016-6694-cve-2016-6695-cve-2016-6696" target="_blank" rel="external">Qualcomm sound driver buffer overflow </a><br>-CVE-2016-6685:<a href="https://source.android.com/security/bulletin/2016-10-01.html" target="_blank" rel="external">kernel info leak</a><br>-CVE-2016-6683:<a href="https://source.android.com/security/bulletin/2016-10-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-6680:<a href="https://source.android.com/security/bulletin/2016-10-01.html" target="_blank" rel="external">Qualcomm wlan driver info leak</a><br>-CVE-2016-6679:<a href="https://source.android.com/security/bulletin/2016-10-01.html" target="_blank" rel="external">Qualcomm wlan driver info leak</a><br>-CVE-2016-3903:<a href="https://source.android.com/security/bulletin/2016-10-01.html" target="_blank" rel="external">Qualcomm camera driver use-after-free</a><br>-CVE-2016-6748:<a href="https://source.android.com/security/bulletin/2016-11-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-6749:<a href="https://source.android.com/security/bulletin/2016-11-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-6750:<a href="https://source.android.com/security/bulletin/2016-11-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-6753:<a href="https://source.android.com/security/bulletin/2016-11-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-6757:<a href="https://source.android.com/security/bulletin/2016-12-01.html" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2016-8466:<a href="https://source.android.com/security/bulletin/2017-01-01.html" target="_blank" rel="external">Broadcom Wi-Fi driver Buffer overflow</a><br>-CVE-2016-8418:<a href="https://source.android.com/security/bulletin/2017-02-01.html" target="_blank" rel="external">Qualcomm crypto driver RCE</a><br>-CVE-2017-0449:<a href="https://source.android.com/security/bulletin/2017-02-01.html" target="_blank" rel="external">Broadcom Wi-Fi driver buffer overflow</a><br>-CVE-2017-0452:<a href="https://source.android.com/security/bulletin/2017-03-01" target="_blank" rel="external">Kernel info leak</a><br>-CVE-2017-0578:<a href="https://source.android.com/security/bulletin/2017-04-01" target="_blank" rel="external">DTS sound driver race condition</a><br>-CVE-2016-5853:<a href="https://www.codeaurora.org/detection-error-condition-without-proper-action-msmds2dapparamvisualizercontrolget-cve-2016-5853" target="_blank" rel="external">Qualcomm sound driver heap overflow</a><br>-CVE-2016-5860:<a href="https://www.codeaurora.org/possible-integer-overflow-buffer-overflow-msmcpelsmregmodel-cve-2016-5860" target="_blank" rel="external">Qualcomm camera driver heap overflow</a><br>-CVE-2016-5859:<a href="https://www.codeaurora.org/possible-integer-overflow-buffer-overflow-msmdolbydapparamvisualizercontrolget-cve-2016-5859" target="_blank" rel="external">Qualcom sound driver heap overflow</a><br>-CVE-2016-5867:<a href="https://www.codeaurora.org/possible-kernel-buffer-overflow-msm-sound-driver-qdsp6v2-function-msmdolbydapparamtosetcontrolput" target="_blank" rel="external">Qualcomm sound driver heap overflow</a><br>-CVE-2016-5346:<a href="https://www.codeaurora.org/potential-information-leak-avtimer-when-processing-ioctlgetavtimertick-cve-2016-5346" target="_blank" rel="external">Qualcomm timer info leak</a><br>-CVE-2016-10231:<a href="https://source.android.com/security/bulletin/2017-04-01" target="_blank" rel="external">Qualcomm sound codec driver EoP</a><br>-CVE-2017-0586:<a href="https://source.android.com/security/bulletin/2017-04-01" target="_blank" rel="external">Qualcomm sound driver information disclosure</a><br>-CVE-2017-8246:<a href="https://www.codeaurora.org/use-after-free-alsa-pcm-playback-kernel-module-cve-2017-8246" target="_blank" rel="external">Qualcomm ALSA PCM Playback UAF</a><br>-CVE-2016-5862:[Qualcomm sound codec driver type confusion]<br>-CVE-2016-5858:[Qualcomm sound codec driver information leakage]<br>-CVE-2017-0608:[Qualcomm sound codec driver buffer overflow]<br>-CVE-2016-5347:[Qualcomm sound codec driver information leakage]<br>-CVE-2017-7369:[ALSA framework stack overflow] </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>个人挖掘的漏洞汇总，分析与PoC仅供学习使用：</p>
<p>-CVE-2015-1835:<a href="http://blog.trendmicro.com/trendlabs-security-intelligence/trend-micro-discovers-a]]>
    </summary>
    
      <category term="CVE" scheme="http://huntcve.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DirtyCow 漏洞分析]]></title>
    <link href="http://huntcve.github.io/2016/10/24/dirtycow-analyze/"/>
    <id>http://huntcve.github.io/2016/10/24/dirtycow-analyze/</id>
    <published>2016-10-24T04:49:36.000Z</published>
    <updated>2016-12-15T01:45:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1_触发内核调用">1 触发内核调用</h1><p>  PoC通过写”/proc/self/mem”触发内核处理Page Fault, 将最终调用__get_user_pages(…,gu_flags=FOL_FORCE,…)</p>
<pre><code>int f=open<span class="list">(<span class="string">"/proc/self/mem"</span>,O_RDWR)</span><span class="comment">;</span>
lseek<span class="list">(<span class="keyword">f</span>,<span class="list">(<span class="keyword">uintptr_t</span>)</span> map,SEEK_SET)</span><span class="comment">;</span>
c+=write<span class="list">(<span class="keyword">f</span>,str,strlen<span class="list">(<span class="keyword">str</span>)</span>)</span><span class="comment">;</span>
</code></pre><a id="more"></a>   
<h1 id="2___get_user_pages(…)">2 __get_user_pages(…)</h1><p>   该函数是内核用来获取用户进程页面，分配物理内存，进行后续读、写等相关操作。</p>
<pre><code><span class="keyword">long</span> __get_user_pages(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,
    <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,
    <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, <span class="keyword">struct</span> page **pages,
    <span class="keyword">struct</span> vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)
{
    ...

    <span class="keyword">do</span> {
        <span class="keyword">struct</span> page *page;
        <span class="keyword">unsigned</span> <span class="keyword">int</span> foll_flags = gup_flags;
        <span class="keyword">unsigned</span> <span class="keyword">int</span> page_increm;

        <span class="comment">/* first iteration or cross vma bound */</span>
        <span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) {
            vma = find_extend_vma(mm, start);
            ...
        }

retry:
        ...
        cond_resched();
        page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);
        <span class="keyword">if</span> (!page) {
            <span class="keyword">int</span> ret;
            ret = faultin_page(tsk, vma, start, &amp;foll_flags,
                    nonblocking);
            <span class="keyword">switch</span> (ret) {
            <span class="keyword">case</span> <span class="number">0</span>:
                <span class="keyword">goto</span> retry;
            <span class="keyword">case</span> -EFAULT:
            <span class="keyword">case</span> -ENOMEM:
            <span class="keyword">case</span> -EHWPOISON:
                <span class="keyword">return</span> i ? i : ret;
            <span class="keyword">case</span> -EBUSY:
                <span class="keyword">return</span> i;
            <span class="keyword">case</span> -ENOENT:
                <span class="keyword">goto</span> next_page;
            }
            BUG();
        } <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) {
            <span class="keyword">goto</span> next_page;
        } <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) {
            <span class="keyword">return</span> i ? i : PTR_ERR(page);
        }
        <span class="keyword">if</span> (pages) {
            pages[i] = page;
            flush_anon_page(vma, page, start);
            flush_dcache_page(page);
            page_mask = <span class="number">0</span>;
        }
next_page:
        ...
        i += page_increm;
        start += page_increm * PAGE_SIZE;
        nr_pages -= page_increm;
    } <span class="keyword">while</span> (nr_pages);
    <span class="keyword">return</span> i;
}
</code></pre><p>函数是一个do循环，首先搜索VMA，然后进行各种读、写Page Fault的处理。注意这里有一个retry逻辑，这是整个漏洞得以形成的关键。 因为Page Fault处理中涉及物理页面的映射以及一些数据的拷贝，这是一个比较耗时的工作，所以程序调用了cond_resched()主动触发CPU调度，即在此可以允许其他任务优先执行。这里就导致了潜在的条件竞争。其后调用follow_page_mask，从用户地址空间里查找页面描述符，并返回一个struct page结构的页面指针。如果该页面指针为空，即未找到，调用faultin_page处理Page Fault, 该函数如果返回0再进入retry流程，其他则直接报错返回或进入下一页面。 </p>
<h1 id="3_follow_page_mask调用了follow_page_pte">3 follow_page_mask调用了follow_page_pte</h1><pre><code><span class="keyword">struct</span> page *follow_page_mask(<span class="keyword">struct</span> vm_area_struct *vma,
              <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,
              <span class="keyword">unsigned</span> <span class="keyword">int</span> *page_mask)
{
...
    <span class="keyword">if</span> (likely(!<span class="keyword">pmd_t</span>rans_huge(*pmd)))
        <span class="keyword">return</span> follow_page_pte(vma, address, pmd, flags);
...
}
</code></pre><h1 id="4_follow_page_pte">4 follow_page_pte</h1><pre><code>static struct page <span class="built_in">*</span>follow_page_pte<span class="params">(struct vm_area_struct *vma,
    unsigned long address, pmd_t *pmd, unsigned int flags)</span>
{

retry:
    <span class="keyword">if</span> <span class="params">(unlikely<span class="params">(pmd_bad<span class="params">(*pmd)</span>)</span>)</span>
        return no_page_table<span class="params">(vma, flags)</span>;

...
    <span class="keyword">if</span> <span class="params">(!pte_present<span class="params">(pte)</span>)</span> { ------------------------分支<span class="number">1</span>
    ...
        <span class="keyword">if</span> <span class="params">(pte_none<span class="params">(pte)</span>)</span>
            goto no_page;
    ..
    }
...
    <span class="keyword">if</span> <span class="params">(<span class="params">(flags &amp; FOLL_WRITE)</span> &amp;&amp; !pte_write<span class="params">(pte)</span>)</span> {--------------分支<span class="number">2</span>
        pte_unmap_unlock<span class="params">(ptep, ptl)</span>;
        return NULL;
    }
...
out:
    pte_unmap_unlock<span class="params">(ptep, ptl)</span>;
    return page;
no_page:
    pte_unmap_unlock<span class="params">(ptep, ptl)</span>;
    <span class="keyword">if</span> <span class="params">(!pte_none<span class="params">(pte)</span>)</span>
        return NULL;
    return no_page_table<span class="params">(vma, flags)</span>;
}
</code></pre><p>这里有两种情况：一种是page不存在,条件竞争的时候被madvice释放了；另一种是madvice还没开始调用，这时候page是存在的，但页表PTE指向的是只读区，产生的是读异常，对于写就返回NULL。这两种情况函数都返回NULL，前者走分支1，后者走分支2。注意这里的flags变量是一开始传入的FOL_FORCE，代表强制读写， pte_write(pte)检测页表里的可写位。因为此块内存是只读映射所以pte_write返回false，因而分支2总是能满足。</p>
<h1 id="5_进入faultin_page">5 进入faultin_page</h1><pre><code><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> vm_area_struct *vma,
    <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span>
</span>{
    ...
    <span class="keyword">if</span> (*flags &amp; FOLL_WRITE)
        fault_flags |= FAULT_FLAG_WRITE;
    <span class="keyword">if</span> (*flags &amp; FOLL_REMOTE)
        fault_flags |= FAULT_FLAG_REMOTE;
    ...

    ret = handle_mm_fault(mm, vma, address, fault_flags);
    <span class="keyword">if</span> (ret &amp; VM_FAULT_ERROR) {
        <span class="keyword">if</span> (ret &amp; VM_FAULT_OOM)
            <span class="keyword">return</span> -ENOMEM;
        <span class="keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))
            <span class="keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;
        <span class="keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))
            <span class="keyword">return</span> -EFAULT;
        BUG();
    }

    ...

    <span class="comment">/*
     * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when
     * necessary, even if maybe_mkwrite decided not to set pte_write. We
     * can thus safely do subsequent page lookups as if they were reads.
     * But only do so when looping for pte_write is futile: in some cases
     * userspace may also be wanting to write to the gotten user page,
     * which a read fault here might prevent (a readonly page might get
     * reCOWed by userspace write).
     */</span>
    <span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))
        *flags &amp;= ~FOLL_WRITE;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>这个函数主要进行缺页异常处理。一开始会将异常标志fault_flags设FAULT_FLAG_WRITE，表示这是写异常。 其次调用handle_mm_fault进行异常处理，并根据其返回值判断是否需要移除写标志。函数正常情况下返回0.注意这里面会检测VM_FAULT_WRITE和VM_WRITE位，并据此判断是否要移除写标志，即进入读异常相应状态。 这是本漏洞的重点。 因为这里有一个写读反转的过程。</p>
<h1 id="6_handle_mm_fault">6 handle_mm_fault</h1><p>直接调用__handle_mm_fault</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">handle_mm_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,
        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span>
</span>{
    ...

    ret = __handle_mm_fault(mm, vma, address, flags);

    ...
    <span class="keyword">return</span> ret;
}
</code></pre><h1 id="7___handle_mm_fault">7 __handle_mm_fault</h1><p>直接调用handle_pte_fault</p>
<pre><code><span class="keyword">static</span> <span class="keyword">int</span> __handle_mm_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct     *vma, 
         <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)
{
    ...
    pte = pte_offset_map(pmd, address);

    <span class="keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);
}
</code></pre><h1 id="8_handle_pte_fault">8 handle_pte_fault</h1><pre><code>static int handle_pte_fault<span class="params">(struct mm_struct *mm,
         struct vm_area_struct *vma, unsigned long address,
         pte_t *pte, pmd_t *pmd, unsigned int flags)</span>
{
    ...
    <span class="keyword">if</span> <span class="params">(!pte_present<span class="params">(entry)</span>)</span> {
        <span class="keyword">if</span> <span class="params">(pte_none<span class="params">(entry)</span>)</span> {
            <span class="keyword">if</span> <span class="params">(vma_is_anonymous<span class="params">(vma)</span>)</span>
                return do_anonymous_page<span class="params">(mm, vma, address,
                             pte, pmd, flags)</span>;
            <span class="keyword">else</span>
                return do_fault<span class="params">(mm, vma, address, pte, pmd,
                        flags, entry)</span>;
        }
        return do_swap_page<span class="params">(mm, vma, address,
                    pte, pmd, flags, entry)</span>;
    }

    ...
    <span class="keyword">if</span> <span class="params">(flags &amp; FAULT_FLAG_WRITE)</span> {
        <span class="keyword">if</span> <span class="params">(!pte_write<span class="params">(entry)</span>)</span>
            return do_wp_page<span class="params">(mm, vma, address,
                    pte, pmd, ptl, entry)</span>;
        entry = pte_mkdirty<span class="params">(entry)</span>;
    }
    entry = pte_mkyoung<span class="params">(entry)</span>;
    <span class="keyword">if</span> <span class="params">(ptep_set_access_flags<span class="params">(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)</span>)</span> {
        update_mmu_cache<span class="params">(vma, address, pte)</span>;
    } <span class="keyword">else</span> {
        <span class="comment">/*
         * This is needed only for protection faults but the arch code
         * is not yet telling us if this is a protection fault or not.
         * This still avoids useless tlb flushes for .text page faults
         * with threads.
         */</span>
        <span class="keyword">if</span> <span class="params">(flags &amp; FAULT_FLAG_WRITE)</span>
            flush_tlb_fix_spurious_fault<span class="params">(vma, address)</span>;
    }
unlock:
    pte_unmap_unlock<span class="params">(pte, ptl)</span>;
    return <span class="number">0</span>;
}
</code></pre><p>未完待续…</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_触发内核调用">1 触发内核调用</h1><p>  PoC通过写”/proc/self/mem”触发内核处理Page Fault, 将最终调用__get_user_pages(…,gu_flags=FOL_FORCE,…)</p>
<pre><code>int f=open<span class="list">(<span class="string">"/proc/self/mem"</span>,O_RDWR)</span><span class="comment">;</span>
lseek<span class="list">(<span class="keyword">f</span>,<span class="list">(<span class="keyword">uintptr_t</span>)</span> map,SEEK_SET)</span><span class="comment">;</span>
c+=write<span class="list">(<span class="keyword">f</span>,str,strlen<span class="list">(<span class="keyword">str</span>)</span>)</span><span class="comment">;</span>
</code></pre>]]>
    
    </summary>
    
      <category term="vulnerability, CVE-2016-5195" scheme="http://huntcve.github.io/tags/vulnerability-CVE-2016-5195/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Blackhat USA 2016 观感]]></title>
    <link href="http://huntcve.github.io/2016/08/05/blackhat-USA-2016/"/>
    <id>http://huntcve.github.io/2016/08/05/blackhat-USA-2016/</id>
    <published>2016-08-05T07:38:51.000Z</published>
    <updated>2016-08-05T10:05:30.000Z</updated>
    <content type="html"><![CDATA[<p>今年有幸参加Blackhat USA 这一全球安全行业盛会，拓广了见识，收获颇多，仅以此文聊留念。</p>
<a id="more"></a>
<h1 id="行程与住宿">行程与住宿</h1><p>从南京至拉斯维加斯航班较少，且票价巨贵，因此一开始就决定从浦东出发。综合了几家航空公司后选择了大韩航空，主要是基于票价便宜（来回8200）服务好空姐靓之考虑，取道仁川，直飞拉斯维加斯McCarran机场。<br>到维加斯后首先入住的是著名的金字塔（luxor）酒店，这个酒店浓浓的埃及风格，看外观就知别有特色。<br><img src="/images/bhusa/luxor.jpg" alt="金字塔酒店外观" title="金字塔酒店外观"><br>内部也是相当气派:<br><img src="/images/bhusa/luxor_in.jpg" alt="金字塔酒店外内部" title="金字塔酒店内部"><br>相比较而言，房间就比较一般了，设施陈旧，窗户压抑，空调巨响，还要手动控制，连住三晚均无法入眠。<br><img src="/images/bhusa/luxor_room.jpg" alt="金字塔酒店房间" title="金字塔酒店房间"><br>于是第四日果断换至会议所在酒店，Mandalay Bay. 事实证明虽然价格高了一点，但这个酒店确实要好一点，设施比较新，房间够大，设计合理，电视还能看XX频道，不过我没看。 凭窗欣赏维加斯夜景还是不错的：<br><img src="/images/bhusa/Mandalay.jpg" alt="Mandalay房间" title="Mandalay房间"><br>Mandaly Bay虽然名字有海湾但并不靠海，拉斯维加斯处于内陆内华达沙漠，炎热干燥无比，大概是本地人太想念海了，于是就取了这么个名字。 其实不过是酒店楼下弄了个人造泳池，设计成海湾的样子罢了。<br>这边酒店除了公开的住宿费之外，还会收取不少的度假费和税，税收为12%，度假费一般15$ - 30$不等。  </p>
<h1 id="吃饭">吃饭</h1><p>吃饭是个大问题。据说这里有中餐馆，但因为地不熟，也就没有贸然出去乱寻。在酒店饮食广场点了一杯可乐，两个批萨，20$。 放国内相当不值！<br><img src="/images/bhusa/food.jpg" alt="吃饭" title="吃饭"><br>于是第二天起决定吃酒店的自助，早中晚都有，一般20$-30$左右。<br><img src="/images/bhusa/buffet.jpg" alt="自助" title="自助"><br>其实自助也没多少东西可吃的，20$在国内可吃不错的自助，比如多伦多，海鲜无限吃，在这边，没有海鲜，荤菜品种很少，大部分是沙拉和水果。有一顿吃了个35$的，海鲜是有了，不过只有蟹脚与少量的生鱼片寿司，挺坑爹的。   </p>
<h1 id="会议">会议</h1><p>作为全球最具影响力的安全盛会，大部分分享都干活十足，极具含金量。我总计选了8-9个听了一下。 总结下来，印象最深的是韩国的<a href="https://www.blackhat.com/us-16/briefings/schedule/index.html#breaking-kernel-address-space-layout-randomization-kaslr-with-intel-tsx-3787" target="_blank" rel="external">这位</a>所分享的利用INTEL TSX秒级破解KASLR的研究成果，流利清晰的口语，突破性的技术成果深深折服了在场座无虚席的听众。 另外一个是谷歌Android技术主管Nick分享的他们针对漏洞所出的各种<a href="https://www.blackhat.com/us-16/briefings/schedule/#the-art-of-defense---how-vulnerabilities-help-shape-security-features-and-mitigations-in-android-420" target="_blank" rel="external">缓解措施</a>。鉴于安卓安全研究火热，Nick分享结束后一堆人围绕着咨询，时髦啊！  </p>
<p>个人感觉最烂的分享有仨，严重怀疑这些人是抱着不良目的买进来忽悠听众的，在此爆尸一下：  </p>
<p>1 <a href="https://www.blackhat.com/us-16/briefings/schedule/#cyber-war-in-perspective-analysis-from-the-crisis-in-ukraine-4108" target="_blank" rel="external">讲俄罗斯入侵乌克兰的</a><br> 说它烂是因为这个半小时的分享完全没有技术含量，一直在引用各种twitter照片，说你俄罗斯不承认军事入侵乌克兰，可人家拍了照片，你坦克都来了还抵赖？ 严重怀疑这个分享背后的政治因素。  </p>
<p>2 <a href="https://www.blackhat.com/us-16/briefings/schedule/#hacking-next-gen-atms-from-capture-to-cashout-2863" target="_blank" rel="external">讲让ATM吐钞票的</a><br>  这位来自Rapid7的资深渗透测试研究者，忽悠了所有人。不知从哪里搬来一台神秘的ATM机，屏幕还是用硬纸板遮住。PPT全程讲如何从地下市场购买遗失信用卡，丝毫不讲入侵ATM机细节，然后摆弄了一下，ATM就吐钞票了，操控屏一直盖着也不让看，所有人都迷糊了，挺愕然的， 大家看看然后就散了。 在会议室外面，不少人都对那台神秘的ATM机深表怀疑，唉，丝毫没有已故黑客Barnaby Jack当年的风采。严重怀疑Rapid7唆使此人来忽悠刷个存在而已，节操啊！  </p>
<p>3 <a href="https://www.blackhat.com/us-16/briefings/schedule/#an-ai-approach-to-malware-similarity-analysis-mapping-the-malware-genome-with-a-deep-neural-network-4216" target="_blank" rel="external">讲AI做病毒分析的</a><br>  这是我听的最后一个分享，本来满怀热情，觉得有货，可希望越大失望越大。AI用于AV做病毒分析与扫描是时下研究的热点和潮流。这位又是Ph.D.想想应该不差。一开始还是很正常，讲到如何做特征抽取，映射等。正等着高潮出现，突然间弹出Thank you的页面，附带招聘职位，邮箱等，众人顿时喧哗，这为Ph.D依然自然如我地自我宣讲了一分钟，说希望懂得机器学习有AV背景的加入我们。Fuck，只想说两字，无耻！  </p>
<p>其余的分享中规中矩，TK的分享我去晚了一点，听了一会就Q&amp;A了，于是全体起立离场。走了一半，TK在后面喊，回来，我还没DEMO呢！大家笑笑，还是都走了，也不知道最后有没有Demo成。 这件事说明了一点，在这种多路英雄齐上的会议上，同一时间段有好几场分享，大家已经养成了见了Q&amp;A就起立敢脚的习惯，而且走了，十头牛都别想拉回来。所以说Q&amp;A一定要放到最后，TK这事上失算了。  盘古和keen team的分享干货十足， 但不知是老外听不懂还是不感兴趣，现场的人并不算多，还有一些在中间都陆续离场了，黑头发的倒是不少，看来纯漏洞研究，还是国人感兴趣一点。  </p>
<h1 id="与谷歌的晚宴">与谷歌的晚宴</h1><p> 安卓安全响应团队邀请了Top20左右的漏洞提交者在会议期间与他们team共享晚宴，互相交流交流。 我们到达现场时并没有发现几个中国人，有很多人没去，现场大部分还是谷歌自己的人，包括安卓安全响应团队和Project Zero的几个人。安卓响应团队有好几个华裔,还有来自越南，马来西亚，印度等的，是一支国际纵队。整个晚宴交流比较nice，愉快畅聊。见到了JDuck和Ben Hawkes这俩位世界级牛人，很有风度。 最后他们还给每人发了一部Nexus 5X,一台Pixel平板，以示感谢。 我给Team另一位没来的同事开后门也要了一部pixel，谷歌还是很nice的。<br><img src="/images/bhusa/gift.jpg" alt="Gift" title="Gift">      </p>
<p>总结一下，Blackhat是有水货的，而且水的很彻底，这是不少会议的通病，毕竟人家也是要赚钱的。 听者要自我选择和鉴别，来一趟不容易，能带点东西回去给别人分享分享最好。  </p>
<p>差不多就这些了，后面听下Defcon去Outlets再扫点货走人。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今年有幸参加Blackhat USA 这一全球安全行业盛会，拓广了见识，收获颇多，仅以此文聊留念。</p>]]>
    
    </summary>
    
      <category term="Blackhat" scheme="http://huntcve.github.io/tags/Blackhat/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解Android匿名共享内存与CVE-2016-0846]]></title>
    <link href="http://huntcve.github.io/2016/04/19/cve-2016-0846/"/>
    <id>http://huntcve.github.io/2016/04/19/cve-2016-0846/</id>
    <published>2016-04-19T08:40:12.000Z</published>
    <updated>2016-04-19T08:54:19.000Z</updated>
    <content type="html"><![CDATA[<p>CVE-2016-0846据说是一个比Android出生还早的Android漏洞，理解它先要理解Android共享内存（Ashmem），这里画一张图，便于直观理解：<br><a id="more"></a><br><img src="/images/cve-2016-0846/ashmem.png" alt="Ashmem" title="匿名共享内存"> </p>
<p>【注意点】：</p>
<p>1 IMemory本质上只是个适配器，IMemoryHeap才是真正分配内存的地方。</p>
<p>2 这个共享内存漏洞也是个通用漏洞，android framework里大量使用共享内存，因此不仅影响media server，最严重可获取system权限。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CVE-2016-0846据说是一个比Android出生还早的Android漏洞，理解它先要理解Android共享内存（Ashmem），这里画一张图，便于直观理解：<br>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://huntcve.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解CVE-2015-1805]]></title>
    <link href="http://huntcve.github.io/2016/04/11/cve-2015-1805/"/>
    <id>http://huntcve.github.io/2016/04/11/cve-2015-1805/</id>
    <published>2016-04-11T10:11:22.000Z</published>
    <updated>2016-04-11T10:35:36.000Z</updated>
    <content type="html"><![CDATA[<p>CVE-2015-1805是一个通用型的linux内核任意地址写任意值的漏洞，这种漏洞值得纪念，这里用四张图直观描述一下：<br><a id="more"></a></p>
<p><img src="/images/cve-2015-1805/1.png" alt="初始内存布局" title="初始内存布局"><br><img src="/images/cve-2015-1805/2.png" alt="第一次拷贝后" title="第一次拷贝后"><br><img src="/images/cve-2015-1805/3.png" alt="redo第二次拷贝后" title="redo第二次拷贝后"><br><img src="/images/cve-2015-1805/4.png" alt="第三次拷贝后" title="第三次拷贝后">  </p>
<p>【注意点】：</p>
<p>1 iov_fault_in_pages_write 不会对iov-&gt;iov_base是否是内核指针进行校验，对它的检验是在vfs_read中完成的，因此exploit必须在一个原子pipe_read中完成， 即连续三次拷贝。</p>
<p>2  补丁只是解决了函数内部各变量同步的问题，但引入函数多次调用之间pipe缓存偏移和长度不同步的问题（CVE-2016-0774）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CVE-2015-1805是一个通用型的linux内核任意地址写任意值的漏洞，这种漏洞值得纪念，这里用四张图直观描述一下：<br>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://huntcve.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一步调通stagefright exploit]]></title>
    <link href="http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/"/>
    <id>http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/</id>
    <published>2015-12-16T04:58:48.000Z</published>
    <updated>2015-12-17T01:42:50.000Z</updated>
    <content type="html"><![CDATA[<p>古语云：“蒙惠者虽知其然，而未必知其所以然也”。在漏洞利用的学习方面，我们不能只知其然，而必须知其所以然，才能真正掌握利用的精髓，以便学以致用。</p>
<h1 id="前言">前言</h1><p>安卓Media Server的漏洞近一年多以来一直是挖掘的重点。而其中libstagefright无疑是最热点。自从今年八月份jduck公开披露以来，这个模块一直是谷歌撒钱的大户。近期我又从里面挖掘到一个critical的漏洞，有望在明年一月份bulletin里公布。种种迹象表明，这个模块漏洞还没有挖掘干净，应该还要继续臭名昭著一段时间。</p>
<p>目前关于libstagefright开源的exploit有两个版本，一个是jduck公布的<a href="https://blog.zimperium.com/the-latest-on-stagefright-cve-2015-1538-exploit-is-now-available-for-testing-purposes/" target="_blank" rel="external">exploit1</a>,另外一个是谷歌公布的<a href="https://code.google.com/p/google-security-research/issues/attachmentText?id=502&amp;aid=5020005000&amp;name=mp4_stagefright_release.py&amp;token=ABZ6GAdoREMO07ZRfflSFlJct3GtBbtypg%3A1450243091152" target="_blank" rel="external">exploit2</a>。这其中谷歌的版本做法比较精致，精确控制了内存布局，具体可以参见project zero的<a href="http://googleprojectzero.blogspot.tw/2015/09/stagefrightened.html" target="_blank" rel="external">博客</a>。Jduck的版本，网上没有过多的分析文章，乌云上有<a href="http://drops.wooyun.org/papers/10896" target="_blank" rel="external">一篇</a>只分析了一半，很关键的前期内存布局控制及触发点分析没有覆盖到，且作者似乎只是从静态角度分析了exploit chain的调用原理，这对于初学者想要彻底弄清楚整个利用的原理，还显不够。</p>
<p>本文从纯动态调试角度彻底阐述清楚该exploit的原理以及其所包含的问题。  </p>
<a id="more"></a>
<h1 id="源码分析">源码分析</h1><p>在着手调试之前，我们先要分析一下Exploit源码。只有弄懂了代码，调试才能事半功倍。<br>Exploit利用的漏洞是CVE-2015-1538，具体对应的安卓部分代码如下：  </p>
<pre><code>status_t SampleTable::setSampleToChunkParams<span class="params">(off64_t data_offset, size_t data_size)</span> {
<span class="keyword">if</span> <span class="params">(mSampleToChunkOffset &gt;= <span class="number">0</span>)</span> {
    return ERROR_MALFORMED;
}
mSampleToChunkOffset = data_offset;
<span class="keyword">if</span> <span class="params">(data_size &lt; <span class="number">8</span>)</span> {
    return ERROR_MALFORMED;
}
uint8_t header[<span class="number">8</span>];
<span class="keyword">if</span> <span class="params">(mDataSource-&gt;readAt<span class="params">(
            data_offset, header, sizeof<span class="params">(header)</span>)</span> &lt; <span class="params">(ssize_t)</span>sizeof<span class="params">(header)</span>)</span> {
    return ERROR_IO;
}
<span class="keyword">if</span> <span class="params">(U32_AT<span class="params">(header)</span> != <span class="number">0</span>)</span> {
    <span class="comment">// Expected version = 0, flags = 0.</span>
    return ERROR_MALFORMED;
}
mNumSampleToChunkOffsets = U32_AT<span class="params">(&amp;header[<span class="number">4</span>])</span>;
<span class="keyword">if</span> <span class="params">(data_size &lt; <span class="number">8</span> + mNumSampleToChunkOffsets * <span class="number">12</span>)</span> {
    return ERROR_MALFORMED;
}
mSampleToChunkEntries =
    new SampleToChunkEntry[mNumSampleToChunkOffsets]; ----&gt; heap overflow
<span class="keyword">for</span> <span class="params">(uint32_t i = <span class="number">0</span>; i &lt; mNumSampleToChunkOffsets; ++i)</span> {
    uint8_t buffer[<span class="number">12</span>];
    <span class="keyword">if</span> <span class="params">(mDataSource-&gt;readAt<span class="params">(
                mSampleToChunkOffset + <span class="number">8</span> + i * <span class="number">12</span>, buffer, sizeof<span class="params">(buffer)</span>)</span>
            != <span class="params">(ssize_t)</span>sizeof<span class="params">(buffer)</span>)</span> {
        return ERROR_IO;
    }
    CHECK<span class="params">(U32_AT<span class="params">(buffer)</span> &gt;= <span class="number">1</span>)</span>;  <span class="comment">// chunk index is 1 based in the spec.</span>
    <span class="comment">// We want the chunk index to be 0-based.</span>
    mSampleToChunkEntries[i].startChunk = U32_AT<span class="params">(buffer)</span> - <span class="number">1</span>;
    mSampleToChunkEntries[i].samplesPerChunk = U32_AT<span class="params">(&amp;buffer[<span class="number">4</span>])</span>;
    mSampleToChunkEntries[i].chunkDesc = U32_AT<span class="params">(&amp;buffer[<span class="number">8</span>])</span>;
}
return OK;
}
</code></pre><p>其中在分配内存的时候会造成堆溢出，具体原理不再赘述。<br>在Exploit源码中，首先定义了两个地址：  </p>
<pre><code><span class="comment"># The address of a fake StrongPointer object (sprayed)</span>
<span class="variable">sp_addr =</span> <span class="number">0</span>x41d00010 <span class="comment"># takju @ imm76i – 2MB (via hangouts)</span>

<span class="comment"># The address to of our ROP pivot</span>
<span class="variable">newpc_val =</span> <span class="number">0</span>xb0002850 <span class="comment"># point sp at __dl_restore_core_regs</span>
</code></pre><p>其中sp_addr是heap spray后单个buffer的起始地址，newpc_val是god gadget restore_core_regs (libc.so中)的起始地址，具体用作stack pivot. 因为Exploit默认在ASLR disable的情况下工作，因此作者就hardcode了这两个地址。需要说明的是如果你在不同的device测试，这两个地址可能不一样。  </p>
<p>定义好了这两个地址后，就开始创建mp4文件。其中首先会把用来做Heap spray的buffer通过tx3g这个Box写进去：  </p>
<pre><code>page = page[:off] + rop + page[off+len<span class="params">(rop)</span>:] 
spray = page <span class="built_in">*</span> <span class="params">(<span class="params">(<span class="params">(<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span> / len<span class="params">(page)</span>)</span> – <span class="number">20</span>)</span> 
moov_data += make_chunk<span class="params">(‘tx3g’, spray)</span>
</code></pre><p>一共2M左右。单个buffer中包含这几部分数据：</p>
<ul>
<li>decStrong指令需要的相关寄存器数据（用来跳转到ROP）  </li>
<li>restore_core_regs需要的相关寄存器数据（ROP起始，栈翻转）</li>
<li>mprotect需要的相关寄存器数据（堆可执行）</li>
<li>Shellcode</li>
<li>一些其他gadget和补齐数据   </li>
</ul>
<p>需要注意的是，Exploit中tx3g生成的这个堆是放在第一个trak里面的，这会有问题。如果你在调试的过程中发现走到decStrong中必定发生crash,就是由于这个原因导致的，具体后面分析。  </p>
<p>Spray的内容准备好了之后，Exploit中生成了一堆各种各样的data box，这里的作用其实是试图生成堆空隙，以便后面分配的堆能够最终落到前面，为覆盖提供可能。因为从代码看，造成溢出的堆其实是在最后的stsc 这个box解析时分配的，为了避免溢出后没东西可覆盖，需要在前面分配的各种堆中产生空隙，这样才有可能造成最后分配的堆反而跑到前面。安卓代码在解析这些box的时候都会生成临时堆，解析完后即free掉，另外，对同样的box，在第二次解析时会free掉第一次分配的内存（参考MetaData::setData），这两个原因导致这一堆data box解析结束后，在相关位置会留下堆空隙供后续溢出堆使用。 说到这里，解释一下为什么前面说谷歌的版本比较精致，就在于对这块堆布局的处理上，做的比较妥当，基本能保证溢出堆后面必有一个可以被用来利用的对象。而Jduck这个版本，并不能做这种保证，只是提供了可能。在调试的过程中证明了这点，溢出堆跑到前面的概率大概50%左右。  </p>
<p>最后，生成第二个trak，并塞入恶意的stsc box，触发堆溢出：</p>
<pre><code><span class="comment"># Build the nasty sample table to trigger the vulnerability here. </span>
stbl1 = make_stsc(<span class="number">3</span>, (<span class="number">0</span>x1200 / <span class="number">0</span>xc) – <span class="number">1</span>, sp_addr, <span class="keyword">True</span>) <span class="comment"># TRIGGER  </span>
</code></pre><p>这里最终会导致溢出堆之后的0x1200个字节被填入sp_addr。这里的0x1200已经超过了一个内存页，这个值可能是根据调试的device所设定的。不过一股脑溢出超过一个内存页的大小却不希望导致crash这个做法其实挺坑爹的。我在调试的过程中发现，设这么大的值，很容易导致sample table对象被覆盖，于是溢出之后的循环还没跑完就crash了，根本跑不到析构函数里面去。  </p>
<p>到这里总结一下，作者是希望通过对象析构时调用decStrong来触发exploit chain。这就需要保证整个过程不能crash。另外，为了保证进入decStrong后 r0(this)指向sp_addr, 就需要能够覆盖对象指针，这个指针我反复调试之后，确定为是sample table指针，位于trak对象中。当然不同的机型也可能不一样，需要测试。  </p>
<h1 id="问题">问题</h1><p>在调试的过程中，过于信任Exploit源码，没有去质疑而被误导，走了不少弯路。这里把Jduck的源码中的问题罗列一下：</p>
<ul>
<li><p>ROP起始地址问题<br>调试的过程中发现指令走到mprotect函数时老是发生crash，分析了一下堆，发现spray 的堆的内容发生错位。ROP的起始位置不对。看了一下源码，ROP起始地址设的为0x34:</p>
<pre><code><span class="constant">off</span> = 0x34 
<span class="constant">page</span> = page[:off] + rop + page[off+len(rop):] 
...
<span class="comment"># Add some identifiable stuff, just in case something goes awry… </span>
<span class="constant">rop_start_off</span> = 0x34 
<span class="constant">x</span> = rop_start_off + len(rop)
</code></pre><p>根据指令的调试，这个值应该是0x4c (同乌云的那篇文章)。 不知道jduc那边如何考虑，我们需要修改一下。</p>
</li>
<li><p>tx3g box的位置问题<br>前面分析了exploit chain是通过析构触发的。MPEG4Extractor这个类的析构顺序如下：<br>~MPEG4Extractor-&gt;first Trak-&gt;first sp(SampleTable)-&gt;second Trak-&gt;second sp(SampleTable)<br>通过调试发现溢出的堆有50%的概率分配在second Trak之前，极少的概率分配在first Trak或MPEG4Extractor之前，即我们只能覆盖second Trak。但spray buffer是通过first Trak的tx3g 生成的，在析构的时候，first Trak先析构，这样会导致在析构sencond Trak的时候spray buffer已经被free了。由于是2M的大堆，free之后进程已经无法访问。所以会发现decStrong中 的指令LDR   R4, [R0,#4]一经调用，必定会crash。 解决这个问题的办法就是把tx3g box放到第二个trak中，这样在sample table析构之前, spray buffer仍然是活的。下面两张图直观呈现了这个改动：<br><img src="/images/st/tx3g_original.png" alt="改动前" title="改动前"> <img src="/images/st/tx3g_modified.png" alt="改动后" title="改动后"><br>至于原作者为何将tx3g至于第一个trak，目前我还没找到可以解释的合理理由。  </p>
</li>
<li><p>溢出字节的大小问题<br>在内存中几个关键的对象布局大概是这样，从低地址到高地址：<br>MPEG4Extractor对象-Trak1对象-Trak2对象-sample table2对象<br>而我们所关心的溢出堆大概有50%概率会落在Trak1对象与Trak2对象之间。这样就可以通过覆盖Trak2对象中的sample table2对象指针，达到在析构时控制r0的目的。要记住的是不能覆盖sample table2对象，因为在循环里面会用到，一旦覆盖，循环里面就crash了。因此设计一个合理的溢出值，就比较关键。在我的机子上经过若干次调试，我设的这个值为0xA50，大半个内存页的大小，可以使得成功率40-50%左右。  </p>
</li>
<li><p>几个地址问题<br>即使关闭ASLR，不同的版本几个地址也不一样。需要注意的是代码中用到的pop {pc}和pop {r0, r1, r2, r3, r4, pc}是16位的thumb指令，需要将ida中的地址+1。  另外heap spray的预测地址也要根据调试预先定义好。</p>
</li>
</ul>
<h1 id="调试">调试</h1><p>在解决了以上四个关键的问题后，就可以开始调试了。<br>我的机器是华为 T9510E, android 4.0.4.<br>需要先关闭ASLR：</p>
<pre><code>echo <span class="number">0</span> &gt; /<span class="keyword">proc</span>/sys/kernel/randomize_va_space
</code></pre><p>ida attach media server，无需gdb server,直接用自带的android_server, nonpie版本。<br>通过下断点，可以看到第一个分配的Trak1的地址为：0x231d0<br><img src="/images/st/Trak1.png" alt="Trak1对象地址" title="Trak1对象地址">   </p>
<p>第一个分配的stsc1里面的SampleToChunkEntry对象地址为:0x23458<br><img src="/images/st/stsc1.png" alt="stsc1的SampleToChunkEntry对象地址" title="stsc1的SampleToChunkEntry对象地址">   </p>
<p>Trak2的地址为：0x23e70<br><img src="/images/st/trak2.png" alt="Trak2对象地址" title="Trak2对象地址">   </p>
<p>第二个分配的stsc2里面的SampleToChunkEntry对象地址为:0x236d0 (溢出堆),同时看到sample table对象地址为r4=0x24888<br><img src="/images/st/stsc2.png" alt="stsc2的SampleToChunkEntry对象地址" title="stsc2的SampleToChunkEntry对象地址">  </p>
<p>到这里我们可以计算一下，溢出堆到Trak2的距离为 0x23e70 - 0x236d0 = 0x7a0 &lt; 0xa50, 到sample table 对象的距离为 0x24888 - 0x236d0 = 0x11b8 &gt; 0xa50。 即我们的溢出会完全覆盖Track2对象同时不会覆盖到sample table对象，说明这次触发有可能成功。 继续调试：  </p>
<p>发现Trak2对象确实已经被完全覆盖，写入我们的预测地址:<br><img src="/images/st/trak2_overflow.png" alt="Trak2被覆盖" title="Trak2被覆盖">  </p>
<p>循环结束，没有crash，进入MPEG4Extractor的析构，此时发现我们预测的堆已经被spray到，并且刚好是起始位置:<br><img src="/images/st/heap_sprayed.png" alt="heap spray成功" title="heap spray成功">     </p>
<p>Trak1先析构:<br><img src="/images/st/trak1_decons.png" alt="Trak1先析构" title="Trak1先析构">  </p>
<p>Trak2开始析构:<br><img src="/images/st/trak2_decons.png" alt="Trak2开始析构" title="Trak2开始析构">   </p>
<p>sample table开始析构，a1 + 12为 sp(SampleTable)指针，已经被覆盖为sp_addr，所以调用decStrong后 r0即为sp_addr:<br><img src="/images/st/sampletabledecons.png" alt="sample table开始析构" title="sample table开始析构">   </p>
<p>进入decStrong, r0指向spray buffer头：<br><img src="/images/st/decstrong.png" alt="decStrong" title="decStrong">   </p>
<p>进入god gadget restore_core_regs, r0已经更新:<br><img src="/images/st/restorecorereg.png" alt="restore_core_regs" title="restore_core_regs">  </p>
<p>进入mprotect,r0已经被更新为页首，其他参数已经设入：<br><img src="/images/st/mprotect.png" alt="mprotect" title="mprotect">   </p>
<p>第一个pop, 16位的thumb指令:<br><img src="/images/st/pop1.png" alt="第一个pop" title="第一个pop">   </p>
<p>第二个pop, 16位的thumb指令:<br><img src="/images/st/pop2.png" alt="第二个pop" title="第二个pop"></p>
<p>shellcode, 即乌云文中所翻译的那段指令：<br><img src="/images/st/shellcode.png" alt="shellcode" title="shellcode"> </p>
<p>最终:<br><img src="/images/st/shell.png" alt="reverse shell" title="reverse shell">  </p>
<h1 id="总结">总结</h1><p>因为Media server crash后会不断重启，所以通过反复触发总能成功。我的机器概率大概是5-8次重启，能保证有一次成功。本文主要以动态调试方法详细阐述了该exploit的原理及相关问题，实践出真知，这些问题，或许因为某些原因在原作者的设备上并不存在（我对此表示怀疑），但通过这个调试过程，我们可以对漏洞利用的一般性方法有一个大概的了解。对文中指出的几个问题，有不同见解的朋友可以留言讨论。  </p>
<h1 id="修改的代码链接">修改的代码链接</h1><p><a href="https://github.com/huntcve/exploit/blob/master/cve-2015-1538-update.py" target="_blank" rel="external">CVE-2015-1538-update.py</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>古语云：“蒙惠者虽知其然，而未必知其所以然也”。在漏洞利用的学习方面，我们不能只知其然，而必须知其所以然，才能真正掌握利用的精髓，以便学以致用。</p>
<h1 id="前言">前言</h1><p>安卓Media Server的漏洞近一年多以来一直是挖掘的重点。而其中libstagefright无疑是最热点。自从今年八月份jduck公开披露以来，这个模块一直是谷歌撒钱的大户。近期我又从里面挖掘到一个critical的漏洞，有望在明年一月份bulletin里公布。种种迹象表明，这个模块漏洞还没有挖掘干净，应该还要继续臭名昭著一段时间。</p>
<p>目前关于libstagefright开源的exploit有两个版本，一个是jduck公布的<a href="https://blog.zimperium.com/the-latest-on-stagefright-cve-2015-1538-exploit-is-now-available-for-testing-purposes/">exploit1</a>,另外一个是谷歌公布的<a href="https://code.google.com/p/google-security-research/issues/attachmentText?id=502&amp;aid=5020005000&amp;name=mp4_stagefright_release.py&amp;token=ABZ6GAdoREMO07ZRfflSFlJct3GtBbtypg%3A1450243091152">exploit2</a>。这其中谷歌的版本做法比较精致，精确控制了内存布局，具体可以参见project zero的<a href="http://googleprojectzero.blogspot.tw/2015/09/stagefrightened.html">博客</a>。Jduck的版本，网上没有过多的分析文章，乌云上有<a href="http://drops.wooyun.org/papers/10896">一篇</a>只分析了一半，很关键的前期内存布局控制及触发点分析没有覆盖到，且作者似乎只是从静态角度分析了exploit chain的调用原理，这对于初学者想要彻底弄清楚整个利用的原理，还显不够。</p>
<p>本文从纯动态调试角度彻底阐述清楚该exploit的原理以及其所包含的问题。  </p>]]>
    
    </summary>
    
      <category term="Stagefright, exploit" scheme="http://huntcve.github.io/tags/Stagefright-exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从zergRush深入理解Use After Free]]></title>
    <link href="http://huntcve.github.io/2015/06/14/uaf/"/>
    <id>http://huntcve.github.io/2015/06/14/uaf/</id>
    <published>2015-06-14T13:48:13.000Z</published>
    <updated>2015-06-14T14:14:30.000Z</updated>
    <content type="html"><![CDATA[<p>古语“道高一尺，魔高一丈”，用在如今的安全领域十分的恰如其分。</p>
<p>Use After Free(UAF)类型的漏洞近些年特别活跃，从WEB到桌面到移动端，屡屡被暴露于各种设备、平台、软件之中，究其原因，恐怕与系统软件厂商在针对传统型漏洞如缓冲区溢出等方面所作的持续性增强防范策略（Stack Canary, DEP/NX, ASLR…）不无干系。本文就Android平台一个知名UAF漏洞利用案列(zergRush)进行分析，深度探究UAF漏洞形成的原因及利用方法。</p>
<a id="more"></a>
<h1 id="Use_After_Free漏洞定义">Use After Free漏洞定义</h1><p>CWE 给出的定义如下：</p>
<blockquote>
<p>引用一段被释放的内存可导致程序崩溃，或处理非预期数值，或执行无干指令。</p>
</blockquote>
<p>扩展描述中有如下阐述：</p>
<blockquote>
<p>使用被释放的内存可带来诸多不利后果，根据具体实例和缺陷发生时机，轻则导致程序合法数据被破坏，重则可执行任意指令。最简单的导致数据被破坏的场景是系统对被释放内存进行了重利用。<br>UAF错误一般有两种原因导致：<br>•导致程序出错和发生异常的各种条件<br>•程序负责释放内存的指令发生混乱<br>问题内存在被释放后，在某个时间点又被合法地分配给了其他的指针，随后，这块内存释放之前的指针又被重新使用并且指向了新分配的同一内存的某个区域，但该段内存的数据已经发生变化，所有就造成了释放前指针对象的数据被破坏，这会导致程序行为未知。<br>如果碰巧这块问题内存新分配的数据是比如C++中的类，那这块内存堆上可能散落着各种函数指针，只要用shellcode的地址覆盖其中一个函数指针，就能够达成执行任意指令。 </p>
</blockquote>
<p>一个典型的UAF错误如下： </p>
<pre><code><span class="comment">//Example code, Language: C</span>
char<span class="built_in">*</span> ptr = <span class="params">(char*)</span>malloc <span class="params">(SIZE)</span>;
<span class="keyword">if</span> <span class="params">(err)</span> {
    abrt = <span class="number">1</span>;
    free<span class="params">(ptr)</span>;
}
...
<span class="keyword">if</span> <span class="params">(abrt)</span> {
    logError<span class="params">(<span class="string">"operation aborted before commit"</span>, ptr)</span>;
}
</code></pre><p>这里一旦错误发生，内存立刻被free，但内存指针ptr随后却被重新使用，从而引发错误。如果ptr在使用之前程序调用内存分配器申请内存并赋值给其他类型或对象指针，很有可能内存分配器分配的是同一块内存，结果就造成了两个不同类型的指针指向同一块内存，产生了混乱。根据程序实现的特定逻辑，这种混乱可能会使得恶意攻击成为可能，并且可以绕开传统的系统防御策略，如：stack cookie, DEP, ASLR。<br>这个例子是最简单的一种UAF错误场景，产生的原因是引用了悬挂指针（Dangling pointer）。如果在指针free后及时置NULL,那么对NULL指针的任何应用将导致程序终止，从而避免恶意利用的发生。<br>那是不是只要指针被释放后置NULL就可以避免产生UAF漏洞了？答案显然是NO。<br>CWE提供的对该漏洞的潜在缓解策略如下： </p>
<ul>
<li>选择具有自动内存管理功能的编程语言   </li>
<li>释放内存时务必置空指针。尽管如此，这种方法对针对多重或复杂数据结构利用的有效性有限 </li>
</ul>
<p>简言之，如果你不是用的像Java这样具有自动内存管理功能的高级语言，而是C/C++这样的需要自己管理内存的语言，即使没有犯明显的重用悬挂指针错误，一样也可能遭受UAF攻击。<br>这对C/C++编程者来说可能是个噩耗。事实上，UAF漏洞的攻击也确实基本都是针对C/C++这类原生程序的攻击，比如各类浏览器， ActiveX插件，操作系统等。下面我们结合一个在Android系统上知名的UAF漏洞利用（zergRush）案例深入分析一下这种攻击的原理和场景。 </p>
<h1 id="zergRush_(CVE-2011-3874)">zergRush (CVE-2011-3874)</h1><p>CVE-2011-3874是Android系统早期一个著名的漏洞，被Revolutionary 小组用来集成在zergRush工具中对Android2.2-2.3版本进行ROOT提权。网上对该漏洞的原理分析并不多，<a href="http://www.2cto.com/Article/201410/339738.html" target="_blank" rel="external">zergRush (CVE-2011-3874)提权漏洞分析</a>算是讲的比较具体的，但有几个关键点没有讲清楚，导致初学者可能不太容易理解，并且这几个关键点是整个漏洞利用的精髓，涉及到UAF产生和利用的原理，因此有必要在这里重新交代一下，以便更好地理解UAF，当然，直接看懂了的可略过。 </p>
<p>不赘述，直接进入要点： </p>
<h2 id="关键点一：free任意地址">关键点一：free任意地址</h2><p>use-after-free, 第一步，自然是free。只有能够free掉任意地址，才能利用任意地址，进而做更“龌蹉”的事情。 如果只能free固定地址，对现代的操作系统来说威胁并不大，漏洞进一步利用的空间也不大。要实现free任意地址，就需要指针的值即指针本身所在的栈空间（不是指针指向的堆空间）是可控的。但是程序中指针的值都是strdup返回的，这是内存分配器控制的，我们如何干预呢？<br>argv[argc++] = strdup(tmp);</p>
<p>这就涉及到第二个关键点，缓冲区溢出的用途。 </p>
<h2 id="关键点二：缓冲区溢出与UAF的关系">关键点二：缓冲区溢出与UAF的关系</h2><p>代码其实有两个缓冲区溢出漏洞，一个是字符指针数组argv，一个是字符数组tmp。这里只利用了argv，因为我们要free指针。argv是有16个元素的字符指针数组，按道理只要给它输入17个元素即可溢出且最后一个元素会覆盖到tmp数组的前四个字节，那为何原文要构造18个参数传入呢？<br>“cmd p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 \x78\x56\x34\x12”</p>
<p>既然p16就已经溢出到了tmp内存，为何不把任意地址放在这里而要放在后一位？其实作者在这里没有交代清楚，我们先看一下这个函数的源码（略去了无关部分）： </p>
<pre><code><span class="keyword">void</span> FrameworkListener::dispatchCommand(SocketClient *cli, <span class="keyword">char</span> *data) {      
    FrameworkCommandCollection::iterator i;                                   
    <span class="keyword">int</span> argc = <span class="number">0</span>;                                                             
    <span class="keyword">char</span> *argv[FrameworkListener::CMD_ARGS_MAX];                              
    <span class="keyword">char</span> tmp[<span class="number">255</span>];                                                            
    <span class="keyword">char</span> *p = data;                                                           
    <span class="keyword">char</span> *q = tmp;                                                            
    <span class="keyword">bool</span> esc = <span class="keyword">false</span>;                                                         
    <span class="keyword">bool</span> quote = <span class="keyword">false</span>;                                                       
    <span class="keyword">int</span> k;                                                                    

    <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));                                            
    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));                                              
    <span class="keyword">while</span>(*p) {                                                               
        ...  

        *q = *p++; 
        <span class="comment">//参数截取分支                                                          </span>
        <span class="keyword">if</span> (!quote &amp;&amp; *q == <span class="string">' '</span>) {                                           
            *q = <span class="string">'\0'</span>;                                                       
            argv[argc++] = strdup(tmp);                                      
            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));                                     
            q = tmp;                                                         
            <span class="keyword">continue</span>;                                                        
        }                                                                    
        q++;                                                                 
    }                                                                        

    argv[argc++] = strdup(tmp);                                              
    ....                                                                           
    <span class="keyword">int</span> j;                                                                   
    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)                                               
        <span class="built_in">free</span>(argv[j]);                                                       
    <span class="keyword">return</span>;
} 
</code></pre><p>程序是用空格来分割解析参数的，当解析到第16个空格（即p15 p16之间）的时候，tmp里存的是p15，内存分配器在堆上分配一块新的内存写入p15并把地址赋给argv[15]，随后将tmp数组清空，若参数到p16截止，则while循环不会再进入参数截取分支，读完p16后while结束，此时tmp存的是p16，最后一条strdup会将p16所在的堆的地址写到argv[16],即tmp数组首地址（头4个字节）。这样整个解析流程结束，cmd到p15的堆指针写到了argv[0-15]中，p16的堆地址写到了tmp的前四个字节中，这样任然没办法控制free任意地址，因为argv的17个指针都是strdup返回的,内存布局如下：<br><img src="/images/uaf/uaf_input_17.jpg" alt="输入17个参数" title="输入17个参数]"> </p>
<p>但如果是18个参数，即p16后还有一个参数（这里是\x78\x56\x34\x12），那while循环会继续解析p16和\x78\x56\x34\x12之间的空格，此时tmp存的是p16，内存分配器在堆上分配一块新的内存写入p16并把地址赋给argv[16]，即tmp的前四个字节，同时清空tmp，意味着刚才的地址被置0. 然后程序继续读入\x78\x56\x34\x12到tmp，并且不会进入参数截取分支，跳出while，此时tmp前四字节存的是0x78,0x56,0x34,0x12，即argv[16]指针的值。最后一条strdup将开辟一个新的堆空间并写入\x78\x56\x34\x12，同时将地址赋值给arg[17]，即tmp[4] - tmp[7],不影响tmp[0]-tmp[3]. 至此，argv[0-15]和argv[17]存的都是strdup返回的地址，只有argv[16]存的是我们输入的地址，即0x12345678，达成free任意地址的目的，内存布局如下：<br><img src="/images/uaf/uaf_input_18.jpg" alt="输入18个参数" title="输入18个参数"> </p>
<p>简单的理解，当输入17个参数时，最后一个参数虽然会被写入tmp前四字节，但随即被堆指针覆盖；当输入参数大于17时，最后一个参数被写入tmp前四字节，不会被覆盖，之后的内存才被覆盖。以下是输入19个参数时的内存布局：<br><img src="/images/uaf/uaf_input_19.jpg" alt="输入19个参数" title="输入19个参数">  </p>
<p>因此，利用缓冲区溢出的根本目的是将溢出的指针所在的内存写入我们的输入，即间接给溢出指针赋值，这个过程是与程序实现逻辑息息相关的，18个参数不多不少，刚好满足需求，因地制宜地构造输入，这也是攻击的精髓。 </p>
<h2 id="关键点三：为何要寻找带vtable的对象？">关键点三：为何要寻找带vtable的对象？</h2><p>实际上当我们能够控制free任意指针时，基本能够实现劫持任何对象，这里使用带vtable的FrameworkCommand对象，一方面是因为在函数内部直接调用了该对象的虚函数runCommand,攻击方便，只需对同一函数构造输入二次调用即可，另一方面，带虚函数的对象，vtable的指针都放在对象内存的最前面，也就是我们构造的任意地址，这就使得对象的虚表直接被我们劫持，进而可用任意shellcode地址去覆盖对象的任何函数指针，达到了执行任意代码的目的。</p>
<h2 id="关键点四：为何二次调用dispatchCommand时strdup(tmp)第一次调用返回的即是FrameworkCommand指针？">关键点四：为何二次调用dispatchCommand时strdup(tmp)第一次调用返回的即是FrameworkCommand指针？</h2><p>这取决于内存分配器。Android使用的dlmalloc是一个高效的内存分配器。在某些情况下内存被free后不会马上释放回内核，而是保留给应用程序重新申请。这使得被我们free掉的任意内存，在紧接着下一次分配的过程中，有很大肯能被重新分配使用。第一次strdup正是导致了这样的结果，不同类型的指针指向了同一块内存，当我们用新指针向这块内存写入任意数据的同时，也在覆盖原指针所指向的数据结构。而当原指针复用时，攻击便发生了。这就是use-after-free中的use。 </p>
<p>至此四个关键点分析完成，use-after-free的过程也结束了，我们已经能够开始执行任意代码了。 </p>
<h1 id="总结">总结</h1><p>通过这个案例我们看到，编程人员并没有犯明显的重用悬挂指针错误，但最终还是导致了use-after-free，原因就是因为缓冲区溢出了，并且是指针所在的缓冲区溢出，这就导致溢出的指针超出了程序本身能够掌控的范围，被攻击者利用。同时我们也注意到，该攻击对缓冲区溢出的利用十分聪明，并没有毁坏stack cookie或者是EIP，仅仅溢出了相邻的局部变量的前八个字节，栈帧本身还是完好的，这也是该攻击能够很大程度绕开系统保护措施的主要原因。<br>可以预见，在一定长的时间内，use-after-free还是会成为一种主要的漏洞利用手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>古语“道高一尺，魔高一丈”，用在如今的安全领域十分的恰如其分。</p>
<p>Use After Free(UAF)类型的漏洞近些年特别活跃，从WEB到桌面到移动端，屡屡被暴露于各种设备、平台、软件之中，究其原因，恐怕与系统软件厂商在针对传统型漏洞如缓冲区溢出等方面所作的持续性增强防范策略（Stack Canary, DEP/NX, ASLR…）不无干系。本文就Android平台一个知名UAF漏洞利用案列(zergRush)进行分析，深度探究UAF漏洞形成的原因及利用方法。</p>]]>
    
    </summary>
    
      <category term="vulnerability, 漏洞" scheme="http://huntcve.github.io/tags/vulnerability-%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
</feed>